<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Patient (Procedural)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); height: 100vh; overflow: hidden; }
    .main-container { display: grid; grid-template-columns: 360px 1fr; column-gap: 12px; height: 100vh; width: 100vw; }
    .control-panel { grid-column: 1; width: 360px; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); padding: 20px; overflow-y: auto; position: relative; }
    .control-section { margin-bottom: 25px; }
    .control-section h3 { margin-bottom: 15px; color: #333; border-bottom: 2px solid #3498db; padding-bottom: 5px; }
    .action-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
    .action-btn { padding: 12px 8px; border: none; border-radius: 8px; background: linear-gradient(45deg, #4CAF50, #45a049); color: white; cursor: pointer; font-size: 0.9em; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 3px 8px rgba(76, 175, 80, 0.3); }
    .action-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 12px rgba(76,175,80,0.4); }
    .action-btn:active { transform: translateY(1px); background: linear-gradient(45deg, #45a049, #4CAF50); }
    .clear-btn { background: #e74c3c; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; margin-top: 10px; font-weight: bold; }
    .log-container { background: #1a1a1a; color: #00ff00; padding: 15px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.8em; height: 200px; overflow-y: auto; border: 2px solid #333; }
    .log-entry { margin-bottom: 5px; padding: 2px 0; }
    .log-entry.success { color: #00ff00; }
    .log-entry.error { color: #ff4444; }
    .log-entry.info { color: #44aaff; }
    .character-panel { grid-column: 2; position: relative; overflow: hidden; display: block; background: linear-gradient(180deg, #87CEEB 0%, #98FB98 100%); }
    .canvas-pane { position: relative; width: 100%; height: 100%; }
    #threeContainer { position: absolute; inset: 0; width: 100%; height: 100%; }
    canvas { display: block; }
    .status-display { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.8); color: white; padding: 12px 14px; border-radius: 10px; font-size: 1.0em; font-weight: bold; min-width: 200px; text-align: center; }
    .badge { position: absolute; top: 70px; left: 20px; background: rgba(255,255,255,0.85); color: #333; padding: 6px 10px; border-radius: 6px; font-size: 0.85em; }
  </style>
  <script src="/static/vendor/three/three.min.js"></script>
  <script src="/static/vendor/three/OrbitControls.js"></script>
</head>
<body>
  <div class="main-container">
    <div class="control-panel">
      <div class="control-section">
        <h3>üé≠ Character Actions</h3>
        <div class="action-grid">
          <button class="action-btn" onclick="performAction('wave')">üëã Wave</button>
          <button class="action-btn" onclick="performAction('cough')">üò∑ Cough</button>
          <button class="action-btn" onclick="performAction('headache')">ü§ï Headache</button>
          <button class="action-btn" onclick="performAction('itch')">ü§è Itch</button>
          <button class="action-btn" onclick="performAction('fever')">ü§í Fever</button>
          <button class="action-btn" onclick="performAction('stomach')">ü§± Stomach</button>
          <button class="action-btn" onclick="performAction('leg')">ü¶µ Leg</button>
          <button class="action-btn" onclick="performAction('dizzy')">üòµ Dizzy</button>
          <button class="action-btn" onclick="performAction('sneeze')">ü§ß Sneeze</button>
          <button class="action-btn" onclick="performAction('nausea')">ü§¢ Nausea</button>
          <button class="action-btn" onclick="performAction('blood')">ü©∏ Blood</button>
          <button class="action-btn" onclick="performAction('chest')">‚ù§Ô∏è Chest</button>
        </div>
      </div>
      <div class="control-section">
        <h3>üìù Action Log</h3>
        <div class="log-container" id="actionLog">
          <div class="log-entry info">[SYSTEM] 3D scene initializing‚Ä¶</div>
        </div>
        <button class="clear-btn" onclick="clearLog()">Clear Log</button>
      </div>
    </div>
    <div class="character-panel">
      <div class="canvas-pane">
        <div class="status-display" id="statusDisplay">Building 3D figure‚Ä¶</div>
        <div class="badge">Left mouse: rotate ‚Ä¢ Right mouse: pan ‚Ä¢ Wheel: zoom</div>
        <div id="threeContainer"></div>
      </div>
    </div>
  </div>

  <script>
    // Logs/status
    let currentAction=null, actionTimeout=null;
    function log(msg, type='info'){ const el=document.getElementById('actionLog'); const t=new Date().toLocaleTimeString(); const d=document.createElement('div'); d.className=`log-entry ${type}`; d.textContent=`[${t}] ${msg}`; el.appendChild(d); el.scrollTop=el.scrollHeight; console[type==='error'?'error':'log'](`${type.toUpperCase()}: ${msg}`); }
    function clearLog(){ document.getElementById('actionLog').innerHTML='<div class="log-entry info">[SYSTEM] Log cleared</div>'; }
    function updateStatus(s){ const el=document.getElementById('statusDisplay'); if(el) el.textContent=s; log(`Status: ${s}`,'info'); }

    // Dynamic loader to ensure THREE/controls are available
    function loadScript(url){
      return new Promise((resolve,reject)=>{ const s=document.createElement('script'); s.src=url; s.async=true; s.onload=()=>resolve(); s.onerror=()=>reject(new Error('Failed: '+url)); document.head.appendChild(s); });
    }
    async function ensureThree(){
      if(window.THREE) return;
      // Load local Three.js files
      try {
        await loadScript('/static/vendor/three/three.min.js');
        if(!window.THREE) throw new Error('three.js could not be loaded from local files');
        
        if(!THREE.OrbitControls){
          await loadScript('/static/vendor/three/OrbitControls.js');
        }
      } catch(e) {
        // Fallback to CDN if local files fail
        const threeUrls=[
          'https://unpkg.com/three@0.160.0/build/three.min.js',
          'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js'
        ];
        let lastErr=null;
        for(const u of threeUrls){ try{ await loadScript(u); if(window.THREE) break; } catch(e){ lastErr=e; } }
        if(!window.THREE) throw lastErr || new Error('three.js could not be loaded');
        
        if(!THREE.OrbitControls){
          const ctrlUrls=[
            'https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js',
            'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js'
          ];
          for(const u of ctrlUrls){ try{ await loadScript(u); if(THREE.OrbitControls) break; } catch(_){} }
        }
      }
    }

    // Three.js core
    let scene, camera, renderer, controls, clock;
    const container=document.getElementById('threeContainer');
    function initThree(){
      scene=new THREE.Scene(); scene.background=new THREE.Color(0xbfd9ff);
      camera=new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.1, 100); camera.position.set(0,2.0,6);
      renderer=new THREE.WebGLRenderer({antialias:true});
      renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
      renderer.setSize(container.clientWidth,container.clientHeight);
      renderer.shadowMap.enabled=true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      renderer.physicallyCorrectLights = true;
      container.appendChild(renderer.domElement);
      const hemi=new THREE.HemisphereLight(0xffffff,0x444444,1.0); hemi.position.set(0,2,0); scene.add(hemi);
      const dir=new THREE.DirectionalLight(0xffffff,1.0); dir.position.set(3,5,2); dir.castShadow=true; scene.add(dir);
      const ground=new THREE.Mesh(new THREE.PlaneGeometry(20,20), new THREE.MeshStandardMaterial({color:0xd3f2d3,roughness:1})); ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; scene.add(ground);
      try{
        if(THREE.OrbitControls){ controls=new THREE.OrbitControls(camera, renderer.domElement); controls.target.set(0,1.2,0); controls.update(); }  // Adjusted target for lowered head
        else { log('OrbitControls not available; using fixed camera','info'); }
      }catch(e){ log('OrbitControls init failed: '+e.message,'error'); }
      clock=new THREE.Clock();
      window.addEventListener('resize', onResize);
      if (window.ResizeObserver){ const ro=new ResizeObserver(()=>onResize()); ro.observe(container); }
      animate();
    }
    function onResize(){ const w=container.clientWidth,h=container.clientHeight; camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h); }
    function animate(){ requestAnimationFrame(animate); const dt=clock.getDelta(); updateRig(dt); updateEffects(dt); renderer.render(scene,camera); }

    // Procedural character rig
    let rig={};
    let activeEffects=[];
    function buildCharacter(){
      const bodyMat=new THREE.MeshStandardMaterial({ color:0x4a90e2, metalness:0.1, roughness:0.85 });
      const skinMat=new THREE.MeshStandardMaterial({ color:0xffdbac, metalness:0.0, roughness:0.9 });
      const hairMat=new THREE.MeshStandardMaterial({ color:0x3b2e2a, metalness:0.0, roughness:1.0 });

      const root=new THREE.Group(); root.position.set(0,0,0); scene.add(root);
      const pelvis=new THREE.Group(); pelvis.position.set(0,0.9,0); root.add(pelvis);
      const torso=new THREE.Mesh(new THREE.CapsuleGeometry(0.22,0.55,8,16), bodyMat); torso.castShadow=true; torso.receiveShadow=true; torso.position.set(0,0.4,0); pelvis.add(torso);
      const chest=new THREE.Group(); chest.position.set(0,0.5,0); torso.add(chest);
      const neck=new THREE.Group(); neck.position.set(0,0.1,0); chest.add(neck);  // Lowered from 0.15 to 0.1 (closer to body)
      const head=new THREE.Mesh(new THREE.SphereGeometry(0.28,24,24), skinMat); head.castShadow=true; head.position.set(0,0.15,0); neck.add(head);  // Lowered from 0.2 to 0.15
      const hair=new THREE.Mesh(new THREE.SphereGeometry(0.29,24,24,0,Math.PI*2,0,Math.PI/2), hairMat); hair.position.copy(head.position).add(new THREE.Vector3(0,0.02,0)); neck.add(hair);

      // Eyes (adjusted for lowered head position)
      const eyeMat=new THREE.MeshStandardMaterial({ color:0xffffff });
      const pupilMat=new THREE.MeshStandardMaterial({ color:0x000000 });
      const eyeL=new THREE.Mesh(new THREE.SphereGeometry(0.04,16,16), eyeMat); eyeL.position.set(-0.09,0.15,0.22);  // Adjusted Y from 0.2 to 0.15
      const eyeR=new THREE.Mesh(new THREE.SphereGeometry(0.04,16,16), eyeMat); eyeR.position.set(0.09,0.15,0.22);   // Adjusted Y from 0.2 to 0.15
      const pupilL=new THREE.Mesh(new THREE.SphereGeometry(0.015,12,12), pupilMat); pupilL.position.set(-0.09,0.14,0.26); // Adjusted Y from 0.19 to 0.14
      const pupilR=new THREE.Mesh(new THREE.SphereGeometry(0.015,12,12), pupilMat); pupilR.position.set(0.09,0.14,0.26);  // Adjusted Y from 0.19 to 0.14
      neck.add(eyeL, eyeR, pupilL, pupilR);

      // Arms (shoulder groups for rotation) - raised 1 time higher
      const shoulderL=new THREE.Group(); shoulderL.position.set(-0.28,-0.15,0); chest.add(shoulderL);  // Raised from -0.25 to -0.15 (1 time higher = +0.10)
      const upperArmL=new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,0.36,16), skinMat); upperArmL.position.set(0,-0.18,0); upperArmL.castShadow=true; shoulderL.add(upperArmL);
      const forearmL=new THREE.Mesh(new THREE.CylinderGeometry(0.055,0.055,0.32,16), skinMat); forearmL.position.set(0,-0.34,0); upperArmL.add(forearmL);
      const handL=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.08,0.08), skinMat); handL.position.set(0,-0.19,0); forearmL.add(handL);

      const shoulderR=new THREE.Group(); shoulderR.position.set(0.28,-0.15,0); chest.add(shoulderR);   // Raised from -0.25 to -0.15 (1 time higher = +0.10)
      const upperArmR=new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,0.36,16), skinMat); upperArmR.position.set(0,-0.18,0); upperArmR.castShadow=true; shoulderR.add(upperArmR);
      const forearmR=new THREE.Mesh(new THREE.CylinderGeometry(0.055,0.055,0.32,16), skinMat); forearmR.position.set(0,-0.34,0); upperArmR.add(forearmR);
      const handR=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.08,0.08), skinMat); handR.position.set(0,-0.19,0); forearmR.add(handR);

      // Legs
      const hipL=new THREE.Group(); hipL.position.set(-0.12,0.0,0); pelvis.add(hipL);
      const thighL=new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.5,16), bodyMat); thighL.position.set(0,-0.25,0); hipL.add(thighL);
      const shinL=new THREE.Mesh(new THREE.CylinderGeometry(0.075,0.075,0.52,16), bodyMat); shinL.position.set(0,-0.38,0); thighL.add(shinL);
      const footL=new THREE.Mesh(new THREE.BoxGeometry(0.14,0.06,0.24), new THREE.MeshStandardMaterial({color:0x654321})); footL.position.set(0,-0.31,0.08); shinL.add(footL);

      const hipR=new THREE.Group(); hipR.position.set(0.12,0.0,0); pelvis.add(hipR);
      const thighR=new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.5,16), bodyMat); thighR.position.set(0,-0.25,0); hipR.add(thighR);
      const shinR=new THREE.Mesh(new THREE.CylinderGeometry(0.075,0.075,0.52,16), bodyMat); shinR.position.set(0,-0.38,0); thighR.add(shinR);
      const footR=new THREE.Mesh(new THREE.BoxGeometry(0.14,0.06,0.24), new THREE.MeshStandardMaterial({color:0x654321})); footR.position.set(0,-0.31,0.08); shinR.add(footR);

      rig={ root, pelvis, torso, chest, neck, head, hair,
            shoulderL, upperArmL, forearmL, handL,
            shoulderR, upperArmR, forearmR, handR,
            hipL, thighL, shinL, footL,
            hipR, thighR, shinR, footR,
            mats:{ bodyMat, skinMat, hairMat } };

      updateStatus('Ready for action testing');
    }

    // Effects helpers
    function generateCircleTexture(){ const s=128,c=document.createElement('canvas'); c.width=c.height=s; const x=c.getContext('2d'); const g=x.createRadialGradient(s/2,s/2,s*0.1,s/2,s/2,s*0.5); g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(255,255,255,0)'); x.fillStyle=g; x.fillRect(0,0,s,s); const t=new THREE.CanvasTexture(c); t.needsUpdate=true; return t; }
    function generateStarTexture(){ const s=128,c=document.createElement('canvas'); c.width=c.height=s; const x=c.getContext('2d'); x.translate(s/2,s/2); x.rotate(-Math.PI/10); x.fillStyle='rgba(255,215,0,1)'; x.beginPath(); for(let i=0;i<5;i++){ x.lineTo(0,-s*0.45); x.translate(0,-s*0.18); x.rotate(Math.PI/5); x.lineTo(0,s*0.18); x.translate(0,s*0.18); x.rotate(-3*Math.PI/5);} x.fill(); const t=new THREE.CanvasTexture(c); t.needsUpdate=true; return t; }

    function addOrbitingStar(duration=3){ const tex=generateStarTexture(); const mat=new THREE.SpriteMaterial({map:tex,transparent:true}); const spr=new THREE.Sprite(mat); spr.scale.set(0.2,0.2,0.2); scene.add(spr); let t=0; activeEffects.push({ttl:duration, update:(dt)=>{ t+=dt; if(!rig.head) return; const hp=rig.head.getWorldPosition(new THREE.Vector3()); const r=0.35, a=t*2.6; spr.position.set(hp.x+Math.cos(a)*r, hp.y+0.15+Math.sin(a*1.3)*0.05, hp.z+Math.sin(a)*r); }, cleanup:()=>{ scene.remove(spr); mat.dispose(); }}); }
    function emitParticles({ color=0xffffff, from='mouth', count=25, spread=0.12, gravity=-0.6, speed=0.8, life=1.2 }){
      const ps=[]; const origin = (()=>{ if(!rig.head) return new THREE.Vector3(0,1.5,0); const p=rig.head.getWorldPosition(new THREE.Vector3()); if(from==='mouth') return p.add(new THREE.Vector3(0, -0.02, 0.2)); if(from==='stomach') { const s=rig.torso.getWorldPosition(new THREE.Vector3()); return s.add(new THREE.Vector3(0, -0.05, 0.15)); } if(from==='rightArm'){ const a=rig.forearmR.getWorldPosition(new THREE.Vector3()); return a.add(new THREE.Vector3(0, -0.15, 0)); } return p; })();
      for(let i=0;i<count;i++){ const m=new THREE.SpriteMaterial({ color, transparent:true, opacity:1 }); const s=new THREE.Sprite(m); s.scale.set(0.04+Math.random()*0.06, 0.04+Math.random()*0.06, 1); s.position.copy(origin); scene.add(s); const vx=(Math.random()-0.5)*spread*speed, vy=Math.random()*spread*speed*0.6, vz=(Math.random()-0.5)*spread*speed; ps.push({s, vx, vy, vz, life: life*(0.7+Math.random()*0.6)}); }
      activeEffects.push({ ttl: Math.max(...ps.map(p=>p.life)), update:(dt)=>{ ps.forEach(p=>{ p.vy += gravity*dt*0.25; p.s.position.x += p.vx*dt; p.s.position.y += p.vy*dt; p.s.position.z += p.vz*dt; p.life -= dt; p.s.material.opacity = Math.max(0, Math.min(1, p.life)); }); }, cleanup:()=>{ ps.forEach(p=>{ scene.remove(p.s); p.s.material.dispose(); }); } });
    }
    function blinkOverlay(where='chest', color=0xff6666, duration=3){ const tex=generateCircleTexture(); const mat=new THREE.SpriteMaterial({map:tex,color,transparent:true,opacity:0.9}); const spr=new THREE.Sprite(mat); const pos = (()=>{ if(where==='chest'){ return rig.chest.getWorldPosition(new THREE.Vector3()).add(new THREE.Vector3(0,-0.3,0.35)); } if(where==='stomach'){ return rig.torso.getWorldPosition(new THREE.Vector3()).add(new THREE.Vector3(0,-0.05,0.35)); } return rig.head.getWorldPosition(new THREE.Vector3()).add(new THREE.Vector3(0,0.05,0.25)); })(); spr.position.copy(pos); spr.scale.set(0.35,0.35,0.35); scene.add(spr); let t=0; activeEffects.push({ ttl:duration, update:(dt)=>{ t+=dt; spr.material.opacity=0.5+0.4*Math.abs(Math.sin(t*6)); }, cleanup:()=>{ scene.remove(spr); mat.dispose(); } }); }
    function setFeverTint(on){ const redColor=on?0xff6666:null; const tint=on?0x772222:0x000000; const intensity=on?0.6:0.0; if(on){ if(rig.head) rig.head.material.color.setHex(redColor); if(rig.upperArmL) rig.upperArmL.material.color.setHex(redColor); if(rig.upperArmR) rig.upperArmR.material.color.setHex(redColor); if(rig.forearmL) rig.forearmL.material.color.setHex(redColor); if(rig.forearmR) rig.forearmR.material.color.setHex(redColor); } else { if(rig.head) rig.head.material.color.setHex(0xffdbac); if(rig.upperArmL) rig.upperArmL.material.color.setHex(0xffdbac); if(rig.upperArmR) rig.upperArmR.material.color.setHex(0xffdbac); if(rig.forearmL) rig.forearmL.material.color.setHex(0xffdbac); if(rig.forearmR) rig.forearmR.material.color.setHex(0xffdbac); } [rig.head,rig.handL,rig.handR].forEach(mesh=>{ if(!mesh) return; const m=mesh.material; if(m && m.isMeshStandardMaterial){ m.emissive=new THREE.Color(tint); m.emissiveIntensity=intensity; }}); }
    function blinkHair(duration=3){ if(!rig.hair) return; const originalColor=0x3b2e2a; let t=0; activeEffects.push({ ttl:duration, update:(dt)=>{ t+=dt; const blinkColor=Math.abs(Math.sin(t*4)) > 0.5 ? 0xff0000 : originalColor; rig.hair.material.color.setHex(blinkColor); }, cleanup:()=>{ rig.hair.material.color.setHex(originalColor); } }); }
    function createItchDots(duration=3){ const dots=[]; const dotPositions=[ {arm:'right',pos:new THREE.Vector3(0.08,0.8,0.2)}, {arm:'right',pos:new THREE.Vector3(0.05,0.6,0.25)}, {arm:'right',pos:new THREE.Vector3(0.12,0.5,0.18)}, {body:'torso',pos:new THREE.Vector3(-0.05,1.2,0.28)}, {body:'torso',pos:new THREE.Vector3(-0.3,1.0,0.3)}, {body:'torso',pos:new THREE.Vector3(0.0,1.4,0.25)} ]; for(let i=0;i<dotPositions.length;i++){ const dotMat=new THREE.SpriteMaterial({color:0xff4444,transparent:true,opacity:0.8}); const dot=new THREE.Sprite(dotMat); dot.scale.set(0.06,0.06,0.06); dot.position.copy(dotPositions[i].pos); scene.add(dot); dots.push(dot); } let t=0; activeEffects.push({ ttl:duration, update:(dt)=>{ t+=dt; dots.forEach((dot,i)=>{ dot.material.opacity=0.4+0.4*Math.abs(Math.sin(t*3+i*0.5)); }); }, cleanup:()=>{ dots.forEach(dot=>{ scene.remove(dot); dot.material.dispose(); }); } }); }
    function createBodyShiver(duration=3){ let t=0; activeEffects.push({ ttl:duration, update:(dt)=>{ t+=dt; if(rig.root){ rig.root.rotation.z = Math.sin(t*8)*0.02; rig.root.position.x = Math.sin(t*12)*0.008; } }, cleanup:()=>{ if(rig.root){ rig.root.rotation.z=0; rig.root.position.x=0; } } }); }
    function clearEffects(){ activeEffects.forEach(e=>{ if(e.cleanup) e.cleanup(); }); activeEffects=[]; }
    function updateEffects(dt){ for(let i=activeEffects.length-1;i>=0;i--){ const e=activeEffects[i]; if(e.update) e.update(dt); e.ttl-=dt; if(e.ttl<=0){ if(e.cleanup) e.cleanup(); activeEffects.splice(i,1); } } }

    // Animation state
    const anim={ wave:0, waveDir:1, leg:0, legDir:1, headWobble:0, headWobbleDir:1, itch:0, itchDir:1, timers:{} };
    function updateRig(dt){
      if(!rig.root) return;
      // gentle idle breathing
      rig.chest.position.y = 0.55 + Math.sin(performance.now()*0.002)*0.01;

      // wave (right arm)
      if(anim.wave>0){ const s=rig.shoulderR; const freq=6; s.rotation.z = Math.sin(performance.now()*0.001*freq)*0.8; }
      // leg swing (left leg)
      if(anim.leg>0){ rig.hipL.rotation.x = Math.sin(performance.now()*0.006)*0.5; rig.hipR.rotation.x = -rig.hipL.rotation.x*0.6; }
      // head wobble (headache/dizzy)
      if(anim.headWobble>0){ rig.neck.rotation.z = Math.sin(performance.now()*0.009)*0.12; }
      // itch: right arm up scratching head (corrected direction, brought to forefront)
      if(anim.itch>0){ rig.shoulderR.rotation.z = -1.2 + Math.sin(performance.now()*0.02)*0.25; rig.forearmR.rotation.x = -0.8; rig.shoulderR.position.z = 0.3; rig.shoulderL.position.z = 0.3; }
    }

    // Actions
    function performAction(type){
      log(`Action triggered: ${type}`,'info');
      clearCurrentAction();
      currentAction=type; updateStatus(`Performing: ${type}`);
      const duration=3000; // ms (3 seconds)

      switch(type){
        case 'wave': anim.wave=1; rig.shoulderR.rotation.x = -0.6; break;
        case 'leg': anim.leg=1; break;
        case 'headache': anim.headWobble=1; blinkOverlay('head',0xff6666,duration/1000); blinkHair(duration/1000); break;
        case 'itch': anim.itch=1; createItchDots(duration/1000); break;
        case 'fever': setFeverTint(true); createBodyShiver(duration/1000); thermometerMesh(duration/1000); break;
        case 'stomach': blinkOverlay('stomach',0xcc8800,duration/1000); handsToStomach(); break;  // Darker orange/yellow for stomach
        case 'chest': blinkOverlay('chest',0xcc0000,duration/1000); break;  // Darker red for chest
        case 'dizzy': anim.headWobble=1; addOrbitingStar(duration/1000); break;
        case 'cough': headNod(); emitParticles({color:0xffffff,from:'mouth',count:24,spread:0.3,gravity:-0.6,speed:1.1,life:1.2}); break;
        case 'sneeze': headNod(true); emitParticles({color:0x99ccff,from:'mouth',count:34,spread:0.45,gravity:-0.8,speed:1.3,life:1.6}); break;
        case 'nausea': emitParticles({color:0x3cb371,from:'mouth',count:36,spread:0.25,gravity:-2.2,speed:0.6,life:1.8}); break;
        case 'blood': emitParticles({color:0x8b0000,from:'rightArm',count:26,spread:0.18,gravity:-2.5,speed:0.5,life:1.5}); emitParticles({color:0x8b0000,from:'stomach',count:18,spread:0.16,gravity:-2.2,speed:0.5,life:1.4}); break;
        default: break;
      }
      actionTimeout=setTimeout(()=>{ clearCurrentAction(); }, duration);
    }

    function clearCurrentAction(){ if(!currentAction) return; log(`Clearing action: ${currentAction}`,'info'); currentAction=null; anim.wave=0; anim.leg=0; anim.headWobble=0; anim.itch=0; rig.shoulderR.rotation.set(0,0,0); rig.shoulderL.rotation.set(0,0,0); rig.shoulderR.position.set(0.28,-0.15,0); rig.shoulderL.position.set(-0.28,-0.15,0); rig.neck.rotation.set(0,0,0); setFeverTint(false); clearEffects(); updateStatus('Ready for next action'); if(actionTimeout){ clearTimeout(actionTimeout); actionTimeout=null; } }

    // Action helpers
    function headNod(snappy=false){ const amp=snappy?0.5:0.35; const t0=performance.now(); const dur=1000; activeEffects.push({ ttl:dur/1000, update:()=>{ const t=(performance.now()-t0)/dur; const e=Math.sin(t*Math.PI); rig.neck.rotation.x = -amp*e; }, cleanup:()=>{ rig.neck.rotation.x=0; } }); }
    function handsToStomach(){ const t0=performance.now(); const dur=700; const startL=rig.shoulderL.rotation.z, startR=rig.shoulderR.rotation.z; activeEffects.push({ ttl:dur/1000, update:()=>{ const t=Math.min(1,(performance.now()-t0)/dur); const e=t<0.5 ? (t*2) : (2-t*2); rig.shoulderL.rotation.z = -0.6*e; rig.shoulderR.rotation.z = 0.6*e; }, cleanup:()=>{ rig.shoulderL.rotation.z=0; rig.shoulderR.rotation.z=0; } }); }
    function thermometerMesh(duration=3){ const g=new THREE.CylinderGeometry(0.01,0.01,0.25,12); const m=new THREE.MeshStandardMaterial({ color:0xff4444, emissive:0x550000 }); const tube=new THREE.Mesh(g,m); const bulb=new THREE.Mesh(new THREE.SphereGeometry(0.025,16,16),m); const mouth=rig.head.getWorldPosition(new THREE.Vector3()).add(new THREE.Vector3(0.12,0,0.02)); tube.position.copy(mouth); bulb.position.copy(mouth).add(new THREE.Vector3(0,-0.14,0)); scene.add(tube,bulb); activeEffects.push({ ttl:duration, cleanup:()=>{ scene.remove(tube); scene.remove(bulb); g.dispose(); m.dispose(); } }); }

    // Keyboard shortcuts
    document.addEventListener('keydown',(e)=>{ const m={'1':'wave','2':'cough','3':'headache','4':'itch','5':'fever','6':'stomach','7':'leg','8':'dizzy','9':'sneeze','q':'nausea','w':'blood'}; if(m[e.key]){ performAction(m[e.key]); log(`Keyboard: ${e.key} -> ${m[e.key]}`,'info'); } });

    // Boot
    window.addEventListener('DOMContentLoaded',async()=>{
      try{
        log('Initializing Three.js‚Ä¶','info');
        await ensureThree();
        initThree();
        buildCharacter();
      }catch(e){
        log('Initialization error: '+(e && e.message ? e.message : e),'error');
        updateStatus('Initialization failed');
      }
    });
  </script>
</body>
</html>

